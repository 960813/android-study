# 운영체제 14주차 / 2020. 12. 03.

## 메모리 관리

### 연속 할당: 외부 단편화 발생

* First Fit, Best Fit, Worst Fit
* 통합 / 압축

### 고정분할 할당: 페이징

* 외부단편화 해결
* 내부단편화 발생

### 가변분할 할당

* 또 다시 외부단편화 발생
* 내부단편화 해결

### 세그먼테이션

* Code, Data, Stack 영역 별 분할/할당
* Base Register / Limit Register 활용
* 만약, 할당된 세그먼테이션을 벗어나 다른 영역을 침범할 경우 Exception 발생
  => 유효하지 않은 주소임, 주소 없음
* 영역 보호, 공유에 유리

### 페이징

* 외부 단편화가 없음

### 페이지화된 세그먼테이션 - paged segment

* 페이징과 세그먼테이션의 장단점 취합
  * 페이징은 내부 단편화가 발생할 수 있으나, 메모리 효율적 사용, 작업 크기가 동일하여 다양한 알고리즘을 개발
  * 세그먼테이션은 외부 단편화가 발생할 수 있으나, 가변적인 데이터 구조와 모듈 처리, 공유와 보호의 지원 편리
* 외부 단편화 문제를 제거하면서 할당 과정을 쉽게 해결
*  메모리를 세그먼트로 나누고, 해당 세그먼트를 페이지로 분할
* 외부단편화 해결, 내부단편화 최소화
* 2중 매핑
  * MMU는 Segment Table에서 각 Segment에 대한 Page 구분
  * 그 후, Page에 대한 Page Table을 이용한 매핑

## 가상 메모리

### 개념

* 메인 메모리 용량을 초과한 프로세스에 주소를 지정해서 메모리를 제한 없이 사용할 수 있또록 하는 것 

### 요구 페이징(Demand Paging)

* 프로세스 실행에 요구되는 페이지만 메모리에 올리는 방법(with Backing Store)
* **Valid Bit**를 이용해 해당 페이지가 메모리에 존재하는지 여부 구분
  * CPU가 페이지를 요구했을 때, 해당 페이지가 메모리에 없다면(v-bit=0) Page Fault(페이지 결함/부재)
    * 왜 ? 페이지를 요구할때만 메모리에 올리기 때문
    * 그럼? 해당 페이지가 메모리에 없고, Backing-Store에 있음
* 장점
  * 메모리 절약 가능
  * 적재된 페이지 중 하나를 수정할 때까지 페이지들은 여러 프로그램이 공유하므로 쓰기복사(COW;Copy-On-Write) 기술로 더 많은 자원을 저장할 수 있다.
* 단점
  * 페이지 교체 알고리즘을 포함하는 메모리 관리가 복잡하다.

### 페이지 부재의 개념

* 프로세스가 비타당(valid = 0)로 표시된 페이지에 액세스하지 않는다면 비타당 비트 여부가 영향을 주지 않으나 메모리에 적재되지 않은 페이지에 액세스하려고 한다면, 페이지 부재 발생

### Page Fault 발생시

* Interrupt 신호 발생
* OS는 Interrupt Service Routine 수행: Backing Store에서 Memory로 인출 수행
* Page Table 갱신
  * Page-Frame 매핑
  * Valid Bit
* 프로세스 재시작

## 유효 액세스 시간(EAT; Effective Access Time)

* 페이지 부재가 발생하지 않으면 유효 액세스 시간은 메모리 액세스 시간과 동일
* 유효 액세스 시간은 페이지 부재 비율에 비례: Page fault YES / NO
* 페이징의 성능
  * Page fault가 발생 하지 않음: page가 frame에 있을 때
  * Page fault가 발생: interrupt->interrupt SR -> 페이지 적재 -> 페이지 테이블 갱신 -> 프로세스 재시작
* 페이지 부재를 최소화하는 것이 중요하다.

## 페이지 성능을 높이는 페이지 대치

* 페이지 대치의 개념
* 

## 페이지 주소 변환 (기말고사) - 20점

