# 운영체제 13주차 / 2020. 11. 26.

## 메모리 관리의 개념

* 프로세스들을 위해 메모리 할당, 제거, 보호하는 활동

## 바인딩

### 정적 바인딩

* 컴파일 타임에 바인딩
* 단일 프로그래밍 시스템에서만 적용 가능

### 동적 바인딩

* loader가 loading을 할 때 바인딩하는 것

### 런타임 바인딩

* 실행 단계에서 바인딩하는 것

## 메모리측면의 메모리 관리

* 메모리에 존재하는 빈 공간을 `Hole` 이라 부른다.
* Process는 메모리에 연속적으로 할당되어야한다.
* 메모리 전체적으로 봤을때, 용량이 있지만 Hole로 인해 Process 할당이 불가능. => `외부 단편화`

## 효율적인 메모리

* 속도가 빨라야 한다.
* 낭비가 최소화되어야 한다.

## 메모리 할당 기법 - 외부 단편화를 줄이기 위한 Fit / 효과가 크지는 않음

* First Fit(최초적합): 가장 최초로 접하는 영역에 할당
* Best Fit(최적 적합): 전체 스캔 후 Fragment가 가장 작게 남는 영역에 할당
* Worst Fit(최악 적합): 전체 스캔 후 fragment가 가장 크게 남는 영역에 할당

## Hole 최소화 기법

* 통합: 연속된 Hole을 합치는 행위
* 압축: 떨어진 Hole을 합치는 행위

## 페이징

* 메모리에 연속적으로 할당된 것 처럼 CPU를 속이는 행위 => 어떻게?
* 프로세스를 동일한 크기로 분할(=`page`)하고, 분할된 메모리(=`frame`) 에 나누어 저장.

### 매핑

* MMU에서 Page table(Page Index - Frame Index 매핑) 이용, 매핑
  * 독립적인 Chip (H/W) / 직접 매핑
  * Cache로 구현: Hit-Rate(적중률)이 중요, 관건 / 연관 매핑
  * 운영체제 내부에서 S/W로 구현 / 연관 + 직접 매핑

### 페이지 요청

	* CPU => \[p|d] => 메모리
	* 페이지 크기가 16바이트라면, d에 4비트 필요
 * \[3|2] => \[1|2] / \[p|d] => \[f|d] / d는 해당 frame 영역에서 몇 바이트 떨어져 있는지 표현
   	* d는 변하지 않음. p에서 f로 변함

### 내부 단편화

* 페이징 과정에서 메모리를 완벽히 사용하지 못하고, 공간이 남는 현상

### 공유 페이지

* 페이징 시스템의 장점인 시분할 환경에서 중요한 공통 코드 공유
* 페이징 시스템에서는 프로세스를 메모리에 연속적으로 할당할 필요가 없기 때문에 여러 프로세스가 메로리 공유 가능
* 다른 프로세스는 메모리의 같은 페이지(지역)을 단순히 가리키도록 해야 하며, 공유 라이브러리 코드에도 사용 가능

### 페이지 보호

* VRWE 보호용비트를 이용해 권한을 관리
  * V: 타당/비타당 => 메인 메모리의 적재 여부
  * R: 읽기 여부
  * W: 수정 여부
  * E: 실행 여부

## 세그먼테이션(segmantation)

* 페이징을 통해 영역을 나누는 경우 같은 프레임에 Code, Data, Stack이 겹칠 수 있음.
* 하나의 프로세스가 가지는 영역(Code, Data, Stack)을 의미있는 영역으로 가변 분할
* 크기가 고정적이지 않아 외부 단편화가 발생할 수 있음

## 페이지화된 세그먼트

* 세그먼트를 페이지화
* Code, Data, Stack 영역을 분할하여 페이징 개념으로 관리