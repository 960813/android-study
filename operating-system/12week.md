# 운영체제 12주차(2020-11-19)

## 시작

* 


## 교착 상태의 발생 조건 

* 상호배제
* 점유와 대기
* 비선점
* 순환(환형) 대기
* 필요 조건
  * 4가지 조건을 모두 만족하더라도 교착 상태가 발생하지 않을 수 있다. 
  * 교착 상태가 발생하려면 4가지 조건을 모두 만족 시켜야 한다.

## 자원 할당 그래프 - 기말 시험

* P1, P2, P3, 자원 R1(Instance 2개), R2(Instance 2개) 어떻게 되어있는지.

## 교착 상태 해결 방법

### 예방(prevention)

교착 상태의 발생 조건 중 최소한 하나라도 성립하지 않도록 자원 요청을 제한

* 각 프로세스는 필요한 자원을 한 번에 모두 요청해야 하며, 요청한 자원을 목두 제공받기 전까지는 작업을 진행할 수 없다.
* 어떤 자원을 점유하고 있는 프로세스의 요청을 더 이상 허용하지 않으면 점유한 자원을 모두 반납하고, 필요할 때 다시 자원을 요청해야 한다.
* 모든 프로세스에 자원을 순서대로 할당해야 한다. 모든 프로세스에 각 자원 유형별로 할당 순서를 부여한 후 순서에 따라 자원을 요청하게 한다.
* 방법
  * 자원의 상호배제 조건 방지 - 이론적으로는 가능하나, 실제로는 적용할 수 없다. 데이터의 소실
  * 점유와 대기 조건 방지 - 
  * 비선점 조건 방지 - 매우 비효율적. 이미 자원을 사용중일 때 이를 선점할 수 있도록 만들면 안되기 때문에 사용 X
  * 순환(환형) 대기 조건 방지 - 주로 사용할 가능성이 높음

### 회피(avoidance)

교착 상태가 발생하는 시점에 다른 자원을 할당 / 자원 할당 거부

* 예방보다는 회피가 더 병행성 허용
* 방법
  * 프로세스의 시작 중단: 프로세스의 요구가 교착 상태를 발생시킬 수 있다면 프로세스 시작 중단
  * 자원 할당 거부(Banker's algorithm): 모니터링을 통해 자원 할당을 거부 / 프로세스가 요청한 자원을 할당했을 때 교착 상태를 발생할 수 있다면 요청한 자원 할당하지 않음

### 탐지(detection), 회복 / 교착이 발생했음을 탐지/감지

* 교착 상태 탐지 알고리즘을 자주 실행하면 시스템의 성능은 하락.
* 교착 상태에 빠진 프로세스를 빨리 발견하여 자원의 유휴 상태를 방지 가능. 하지만 자주 실행하지 않으면 반대 상황 발생
* 탐지와 회복 방법은 필요한 정보를 유지하고 탐지 알고리즘을 실행시키는 비용뿐 아니라 교착 상태 회복에 필요한 부담까지 요청
* 방법
  * 프로세스 중단
    * 교착 상태 프로세스 모두 중단
    * 한 프로세스씩 중단
    * 프로세스 중단이 쉽지 않을 수 있음
    * 최소 비용으로 프로세스들을 중단하는 우선 순위 선정
      * 프로세스가 수행된 시간과 앞으로 종료하는 데 필요한 시간
      * 프로세스가 사용한 자원 형태와 수
      * 프로세스를 종료하는 데 필요한 자원 수
      * 프로세스를 종료하는 데 필요한 프로세스 수
      * 프로세스가 대화식인지, 일괄식인지 여부
  * 자원 선점
    * 선점 자원 선택: 
    * 복귀
    * 기아

## 메모리 관리 정책

```
원시 코드 -> 컴파일러/컴파일 (어셈블러) -> 기계코드(Object 파일) -> 링커/링킹 -> 실행 파일 -> 로더
빌드: Compile + Linking => 컴파일 에러 / 런타임 에러
```

* 적재 정책: 디스크에서 메모리로, 프로세스 반입 시기를 결정하는 것
  * 요구 적재: 운영체제나 시스템 프로그램, 사용자 프로그램 등 참조 요청에 따라 다음에 실행 할 프로세스를 메모리에 적재하는 오래된 방법
  * 예상 적재: 시스템의 요청을 미리 예측하염 ㅔ모리에 적재하는 방법
* 배치 정책: 디스크에서 반입한 프로세스를 메모리 어느 위치에 저장할 것인지 결정
* 대치 정책: 메모리가 충분하지 않을 때 현재 메모리에 적재된 프로세스 중 제거할 프로세스를 결정하는 교체 방법
  => swap device / backing store / swapping(swap-out, swap-in)

### 메모리 매핑(사상)

* CPU에서 Memory에 접근할 때, MMU(Memory Management Unit)을 거친다.
* MMU는 R(Relocator)이 존재하여 CPU 입장의 논리 주소를 메모리의 물리 주소로 Mapping 해준다.
  => PCB의 Base Register, Limit Register 활용.
* MMU: 고정 분할, 동적 분할, 페이징, 세그먼테이션, 페이지화된 세그먼테이션

### 동적 할당 / 동적 적재

* 컴파일 시기에 바인딩하는 것이 아닌, 런타임 시기에 바인딩하는 방법(정적 타이밍이 아닌 동적 타이밍)
* 모든 루틴을 메모리에 적재하지 않고 교체 가능한 형태로 디스크에 저장
* 메인 프로그램만 먼저 메모리에 적재하여 수행
* 사용하지 않을 루틴을 메모리에 적재하지 않으므로 메모리를 효율적으로 사용
* 오류가 발생하기도 하지만 프로그램 전체 양이 많을 때 더 유용
* 단, 정적 할당에 비해 런타임 시기에 속도가 지연(딜레이) 될 수 있다.

### DLL: Dynamic Link Loader

* 공통적으로 사용되는 내용을 별도 메모리에 할당하여 관리
* 